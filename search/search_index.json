{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Froom","text":"<p>Froom provides a neat SQLite abstraction for your Flutter applications inspired by the Room persistence library. It comes with automatic mapping between in-memory objects and database rows while still offering full control of the database with the use of SQL. As a consequence, it's necessary to have an understanding of SQL and SQLite in order to harvest Froom's full potential.</p> <ul> <li>null-safe</li> <li>typesafe</li> <li>reactive</li> <li>lightweight</li> <li>SQL centric</li> <li>no hidden magic</li> <li>no hidden costs</li> <li>iOS, Android, Linux, macOS, Windows</li> </ul> <p>Important</p> <p>The library is open to contributions! Refer to GitHub Discussions for questions, ideas, and discussions.</p> <p> </p>"},{"location":"architecture/","title":"Architecture","text":"<p>The components for storing and accessing data are Entity, Data Access Object (DAO) and Database.</p> <p>The first, Entity, represents a persistent class and thus a database table. DAOs manage the access to Entities and take care of the mapping between in-memory objects and table rows. Lastly, Database, is the central access point to the underlying SQLite database. It holds the DAOs and, beyond that, takes care of initializing the database and its schema. Room serves as the source of inspiration for this composition, because it allows creating a clean separation of the component's responsibilities.</p> <p>The figure shows the relationship between Entity, DAO and Database.</p> <p></p>"},{"location":"changelog/","title":"Changelog","text":"<p>CHANGELOG</p>"},{"location":"daos/","title":"Data Access Objects","text":"<p>These components are responsible for managing access to the underlying SQLite database and are defined as abstract classes with method signatures and query statements. DAO classes can use inherited methods by implementing and extending classes while also using mixins.</p> <pre><code>@dao\nabstract class PersonDao {\n  @Query('SELECT * FROM Person')\n  Future&lt;List&lt;Person&gt;&gt; findAllPeople();\n\n  @Query('SELECT * FROM Person WHERE id = :id')\n  Stream&lt;Person?&gt; findPersonById(int id);\n\n  @insert\n  Future&lt;void&gt; insertPerson(Person person);\n}\n</code></pre>"},{"location":"daos/#queries","title":"Queries","text":"<p>Method signatures turn into query methods by adding the <code>@Query()</code> annotation with the query in parenthesis to them. Be mindful about the correctness of your SQL statements as they are only partly validated while generating the code. These queries have to return either a <code>Future</code> or a <code>Stream</code> of an entity, Dart core type or <code>void</code>.  Retrieval of Dart Core types such as <code>String</code>, <code>double</code>, <code>int</code>, <code>double</code>, <code>Uint8List</code> can be used if you want to get all records from a certain column or return <code>COUNT</code> records in the table.  Returning <code>Future&lt;void&gt;</code> comes in handy whenever you want to delete the full content of a table, for instance.  Some query method examples can be seen in the following.</p> <p>A function returning a single item will return <code>null</code> when no matching row is found. Thereby, the function is required to return a nullable type. For example <code>Person?</code>. This way, we leave the handling of an absent row up to you and don't attempt to guess intention.</p> <pre><code>@Query('SELECT * FROM Person WHERE id = :id')\nFuture&lt;Person?&gt; findPersonById(int id);\n\n@Query('SELECT * FROM Person WHERE id = :id AND name = :name')\nFuture&lt;Person?&gt; findPersonByIdAndName(int id, String name);\n\n@Query('SELECT COUNT(id) FROM Person')\nFuture&lt;int?&gt; getPeopleCount(); // fetch records count\n\n@Query('SELECT name FROM Person')\nFuture&lt;List&lt;String&gt;&gt; getAllPeopleNames(); // fetch all records from one column\n\n@Query('SELECT * FROM Person')\nFuture&lt;List&lt;Person&gt;&gt; findAllPeople(); // select multiple items\n\n@Query('SELECT * FROM Person')\nStream&lt;List&lt;Person&gt;&gt; findAllPeopleAsStream(); // stream return\n\n@Query('DELETE FROM Person')\nFuture&lt;void&gt; deleteAllPeople(); // query without returning an entity\n\n@Query('SELECT * FROM Person WHERE id IN (:ids)')\nFuture&lt;List&lt;Person&gt;&gt; findPeopleWithIds(List&lt;int&gt; ids); // query with IN clause\n</code></pre> <p>Query arguments, when using SQLite's <code>LIKE</code> operator, have to be supplied by the input of a method. It's not possible to define a pattern matching argument like <code>%foo%</code> in the query itself.</p> <pre><code>// dao\n@Query('SELECT * FROM Person WHERE name LIKE :name')\nFuture&lt;List&lt;Person&gt;&gt; findPeopleWithNamesLike(String name);\n\n// usage\nfinal name = '%foo%';\nawait dao.findPeopleWithNamesLike(name);\n</code></pre>"},{"location":"daos/#data-changes","title":"Data Changes","text":"<p>Use the <code>@insert</code>, <code>@update</code> and <code>@delete</code> annotations for inserting and changing persistent data. All these methods accept single or multiple entity instances.</p>"},{"location":"daos/#insert","title":"Insert","text":"<p><code>@insert</code> marks a method as an insertion method. When using the capitalized <code>@Insert</code> you can specify a conflict strategy. Else it just defaults to aborting the insert. These methods can return a <code>Future</code> of either <code>void</code>, <code>int</code> or <code>List&lt;int&gt;</code>. - <code>void</code> return nothing - <code>int</code> return primary key of inserted item - <code>List&lt;int&gt;</code> return primary keys of inserted items</p> <pre><code>@Insert(onConflict: OnConflictStrategy.rollback)\nFuture&lt;void&gt; insertPerson(Person person);\n\n@insert\nFuture&lt;List&lt;int&gt;&gt; insertPeople(List&lt;Person&gt; people);\n</code></pre>"},{"location":"daos/#update","title":"Update","text":"<p><code>@update</code> marks a method as an update method. When using the capitalized <code>@Update</code> you can specify a conflict strategy. Else it just defaults to aborting the update. These methods can return a <code>Future</code> of either <code>void</code> or <code>int</code>. - <code>void</code> return nothing - <code>int</code> return number of changed rows</p> <pre><code>@Update(onConflict: OnConflictStrategy.replace)\nFuture&lt;void&gt; updatePerson(Person person);\n\n@update\nFuture&lt;int&gt; updatePeople(List&lt;Person&gt; people);\n</code></pre>"},{"location":"daos/#delete","title":"Delete","text":"<p><code>@delete</code> marks a method as a deletion method. These methods can return a <code>Future</code> of either <code>void</code> or <code>int</code>. - <code>void</code> return nothing - <code>int</code> return number of deleted rows</p> <pre><code>@delete\nFuture&lt;void&gt; deletePerson(Person person);\n\n@delete\nFuture&lt;int&gt; deletePeople(List&lt;Person&gt; people);\n</code></pre>"},{"location":"daos/#streams","title":"Streams","text":"<p>As already mentioned, queries cannot only return values once when called but also continuous streams of query results. The returned streams keep you in sync with the changes happening in the database tables. This feature plays well with the <code>StreamBuilder</code> widget which accepts a stream of values and rebuilds itself whenever there is a new emission. These methods return broadcast streams and thus, can have multiple listeners.</p> <p>A function returning a stream of single items will emit <code>null</code> when no matching row is found. Thereby, it's necessary to make the function return a stream of a nullable type. For example <code>Stream&lt;Person?&gt;</code>. In case you're not interested in <code>null</code>s, you can simply use <code>Stream.where((value) =&gt; value != null)</code> to get rid of them.</p> <pre><code>// definition\n@dao\nabstract class PersonDao {\n  @Query('SELECT * FROM Person WHERE id = :id')\n  Stream&lt;Person?&gt; findPersonByIdAsStream(int id);\n\n  @Query('SELECT * FROM Person')\n  Stream&lt;List&lt;Person&gt;&gt; findAllPeopleAsStream();\n}\n\n// usage\nStreamBuilder&lt;List&lt;Person&gt;&gt;(\n  stream: dao.findAllPeopleAsStream(),\n  builder: (BuildContext context, AsyncSnapshot&lt;List&lt;Person&gt;&gt; snapshot) {\n    // do something with the values here\n  },\n);\n</code></pre> <p>Attention</p> <ul> <li>Only methods annotated with <code>@insert</code>, <code>@update</code> and <code>@delete</code> trigger <code>Stream</code> emissions.   Inserting data by using the <code>@Query()</code> annotation doesn't.</li> <li>It is now possible to return a <code>Stream</code> if the function queries a database view. But it will fire on any <code>@update</code>, <code>@insert</code>, <code>@delete</code> events in the whole database, which can get quite taxing on the runtime. Please add it only if you know what you are doing!   This is mostly due to the complexity of detecting which entities are involved in a database view.</li> </ul>"},{"location":"daos/#transactions","title":"Transactions","text":"<p>Whenever you want to perform some operations in a transaction you have to add the <code>@transaction</code> annotation to the method. It's also required to add the <code>async</code> modifier. These methods have to return a <code>Future</code>.</p> <pre><code>@transaction\nFuture&lt;void&gt; replacePeople(List&lt;Person&gt; people) async {\n  await deleteAllPeople();\n  await insertPeople(people);\n}\n</code></pre>"},{"location":"daos/#inheritance","title":"Inheritance","text":"<p>Data access object classes support inheritance as shown in the following. There is no limit to inheritance levels and thus, each abstract parent can have another abstract parent. Bear in mind that only abstract classes allow method signatures without an implementation body and thereby, make sure to position your to-be-inherited methods in an abstract class and extend this class with your DAO.</p> <pre><code>@dao\nabstract class PersonDao extends AbstractDao&lt;Person&gt; {\n  @Query('SELECT * FROM Person WHERE id = :id')\n  Future&lt;Person?&gt; findPersonById(int id);\n}\n\nabstract class AbstractDao&lt;T&gt; {\n  @insert\n  Future&lt;void&gt; insertItem(T item);\n}\n\n// usage\nfinal person = Person(1, 'Simon');\nawait personDao.insertItem(person);\n\nfinal result = await personDao.findPersonById(1);\n</code></pre>"},{"location":"database-views/","title":"Database Views","text":"<p>If you want to define static <code>SELECT</code>-statements which return different types than your entities, your best option is to use <code>@DatabaseView</code>. A database view can be understood as a virtual table, which can be queried like a real table.</p> <p>A database view in froom is defined and used similarly to entities, with the main difference being that access is read-only, which means that update, insert and delete functions are not possible. Similarly to entities, the class name is used if no <code>viewName</code> was set.</p> <pre><code>@DatabaseView('SELECT distinct(name) AS name FROM person', viewName: 'name')\nclass Name {\n  final String name;\n\n  Name(this.name);\n}\n</code></pre> <p>Database views do not have any foreign/primary keys or indices. Instead, you should manually define indices which fit to your statement and put them into the <code>@Entity</code> annotation of the involved entities.</p> <p>Setters, getters and static fields are automatically ignored (like in entities), you can specify additional fields to ignore by annotating them with <code>@ignore</code>.</p> <p>After defining a database view in your code, you have to add it to your database by adding it to the <code>views</code> field of the <code>@Database</code> annotation:</p> <pre><code>@Database(version: 1, entities: [Person], views: [Name])\nabstract class AppDatabase extends FroomDatabase {\n  // DAO getters\n}\n</code></pre> <p>You can then query the view via a DAO function like an entity.</p> <p>It is possible for DatabaseViews to inherit common fields from a base class, just like in entities.</p> <p>Attention</p> <p>It is now possible to return a <code>Stream</code> object from a DAO method which queries a database view. But it will fire on any <code>@update</code>, <code>@insert</code>, <code>@delete</code> events in the whole database, which can get quite taxing on the runtime. Please add it only if you know what you are doing! This is mostly due to the complexity of detecting which entities are involved in a database view.</p>"},{"location":"entities/","title":"Entities","text":"<p>An entity is a persistent class. Froom automatically creates the mappings between the in-memory objects and database table rows. It's possible to supply custom metadata to Froom by adding optional values to the <code>Entity</code> annotation. It has the additional attribute of <code>tableName</code> which opens up the possibility to use a custom name for that specific entity instead of using the class name. <code>foreignKeys</code> allows adding foreign keys to the entity. More information on how to use these can be found in the Foreign Keys section. Indices are supported as well. They can be used by adding an <code>Index</code> to the <code>indices</code> value of the entity. For further information of these, please refer to the Indices section.</p> <p><code>@PrimaryKey</code> marks property of a class as the primary key column. This property has to be of type int. The value can be automatically generated by SQLite when <code>autoGenerate</code> is enabled. For more information about primary keys and especially compound primary keys, refer to the Primary Keys section.</p> <p><code>@ColumnInfo</code> enables custom mapping of single table columns. With the annotation it's possible to give columns a custom name. If you want a table's column to be nullable, mark the entity's field as nullable. More information can be found in the Null Safety section.</p> <p>Attention</p> <ul> <li>Froom automatically uses the first constructor defined in the entity class for creating in-memory objects from database rows.</li> <li>There needs to be a constructor.</li> </ul> <pre><code>@Entity(tableName: 'person')\nclass Person {\n  @PrimaryKey(autoGenerate: true)\n  final int id;\n\n  @ColumnInfo(name: 'custom_name')\n  final String name;\n\n  Person(this.id, this.name);\n}\n</code></pre>"},{"location":"entities/#supported-types","title":"Supported Types","text":"<p>Froom entities can hold values of the following Dart types which map to their corresponding SQLite types and vice versa.</p> <ul> <li><code>int</code> - INTEGER</li> <li><code>double</code> - REAL</li> <li><code>String</code> - TEXT</li> <li><code>bool</code> - INTEGER (0 = false, 1 = true)</li> <li><code>Uint8List</code> - BLOB</li> <li><code>enum</code> - INTEGER (records by the index 0..n)</li> </ul> <p>In case you want to store sophisticated Dart objects that can be represented by one of the above types, take a look at Type Converters.</p>"},{"location":"entities/#primary-keys","title":"Primary Keys","text":"<p>Whenever a compound primary key is required (e.g. n-m relationships), the syntax for setting the keys differs from the previously mentioned way of setting primary keys. Instead of annotating a field with <code>@PrimaryKey</code>, the <code>@Entity</code> annotation's <code>primaryKey</code> attribute is used. It accepts a list of column names that make up the compound primary key.</p> <pre><code>@Entity(primaryKeys: ['id', 'name'])\nclass Person {\n  final int id;\n\n  final String name;\n\n  Person(this.id, this.name);\n}\n</code></pre>"},{"location":"entities/#foreign-keys","title":"Foreign Keys","text":"<p>Add a list of <code>ForeignKey</code>s to the <code>Entity</code> annotation of the referencing entity. <code>childColumns</code> define the columns of the current entity, whereas <code>parentColumns</code> define the columns of the parent entity. Foreign key actions can get triggered after defining them for the <code>onUpdate</code> and <code>onDelete</code> properties.</p> <pre><code>@Entity(\n  tableName: 'dog',\n  foreignKeys: [\n    ForeignKey(\n      childColumns: ['owner_id'],\n      parentColumns: ['id'],\n      entity: Person,\n    )\n  ],\n)\nclass Dog {\n  @PrimaryKey()\n  final int id;\n\n  final String name;\n\n  @ColumnInfo(name: 'owner_id')\n  final int ownerId;\n\n  Dog(this.id, this.name, this.ownerId);\n}\n</code></pre>"},{"location":"entities/#indices","title":"Indices","text":"<p>Indices help speeding up query, join and grouping operations. For more information on SQLite indices please refer to the official documentation. To create an index with froom, add a list of indices to the <code>@Entity</code> annotation. The example below shows how to create an index on the <code>custom_name</code> column of the entity.</p> <p>The index, moreover, can be named by using its <code>name</code> attribute. To set an index to be unique, use the <code>unique</code> attribute. <pre><code>@Entity(tableName: 'person', indices: [Index(value: ['custom_name'])])\nclass Person {\n  @primaryKey\n  final int id;\n\n  @ColumnInfo(name: 'custom_name')\n  final String name;\n\n  Person(this.id, this.name);\n}\n</code></pre></p>"},{"location":"entities/#ignoring-fields","title":"Ignoring Fields","text":"<p>Getters, setters and all static fields of entities are ignored by default and thus excluded from the library's mapping. In case further fields should be ignored, the <code>@ignore</code> annotation should be used and applied as shown in the following snippet.</p> <pre><code>class Person {\n  @primaryKey\n  final int id;\n\n  final String name;\n\n  @ignore\n  String nickname;\n\n  // ignored by default\n  String get combinedName =&gt; \"$name ($nickname)\";\n\n  Person(this.id, this.name);\n}\n</code></pre>"},{"location":"entities/#inheritance","title":"Inheritance","text":"<p>Just like Daos, entities (and database views) can inherit from a common base class and use their fields. The entity just has to <code>extend</code> the base class. This construct will be treated as if all the fields in the base class are part of the entity, meaning the database table will have all columns of the entity and the base class.</p> <p>The base class does not have to have a separate annotation for the class. Its fields can be annotated just like normal entity columns. Foreign keys and indices have to be declared in the entity and can't be defined in the base class.</p> <pre><code>class BaseObject {\n  @PrimaryKey()\n  final int id;\n\n  @ColumnInfo(name: 'create_time')\n  final String createTime;\n\n  @ColumnInfo(name: 'update_time')\n  final String updateTime;\n\n  BaseObject(\n    this.id,\n    this.updateTime, {\n    String createTime,\n  }) : this.createTime = createTime ?? DateTime.now().toString();\n\n  @override\n  List&lt;Object&gt; get props =&gt; [];\n}\n\n@Entity(tableName: 'comments')\nclass Comment extends BaseObject {\n  final String author;\n\n  final String content;\n\n  Comment(\n    this.author, {\n    int id,\n    this.content = '', \n    String createTime,\n    String updateTime,\n  }) : super(id, updateTime, createTime: createTime);\n}\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>For further examples take a look at the example and test directories.</p>"},{"location":"feedback/","title":"Bugs, Ideas, and Feedback","text":"<p>For bugs please use GitHub Issues. For questions, ideas, and discussions use GitHub Discussions.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#version-compatibility","title":"Version Compatibility","text":"<p>Please choose the appropriate version based on your <code>source_gen</code> dependency:</p> source_gen Version Froom Version 3.x.x and above 3.x.x 2.x.x 2.0.4"},{"location":"getting-started/#migrating-from-floor","title":"Migrating from Floor","text":"<p>If you're migrating from Floor to Froom, see our Migration Guide for detailed instructions and an automated migration script.</p> <p>\u26a0\ufe0f Important: Always backup your project before migration!</p>"},{"location":"getting-started/#1-setup-dependencies","title":"1. Setup Dependencies","text":"<p>Add the runtime dependency <code>froom</code> as well as the generator <code>froom_generator</code> to your <code>pubspec.yaml</code>. The third dependency is <code>build_runner</code> which has to be included as a dev dependency just like the generator.</p> <ul> <li><code>froom</code> holds all the code you are going to use in your application.</li> <li><code>froom_generator</code> includes the code for generating the database classes.</li> <li><code>build_runner</code> enables a concrete way of generating source code files.</li> </ul> <pre><code>dependencies:\n  flutter:\n    sdk: flutter\n  froom: ^x.x.x\n\ndev_dependencies:\n  froom_generator: ^x.x.x\n  build_runner: ^x.x.x\n</code></pre> <p>\ud83d\udca1 Tip: Use command for easier installation: <pre><code>dart pub add froom dev:froom_generator dev:build_runner\n</code></pre></p>"},{"location":"getting-started/#2-create-an-entity","title":"2. Create an Entity","text":"<p>It will represent a database table as well as the scaffold of your business object. <code>@entity</code> marks the class as a persistent class. It's required to add a primary key to your table. You can do so by adding the <code>@primaryKey</code> annotation to an <code>int</code> property. There is no restriction on where you put the file containing the entity.</p> <pre><code>// entity/person.dart\n\nimport 'package:froom/froom.dart';\n\n@entity\nclass Person {\n  @primaryKey\n  final int id;\n\n  final String name;\n\n  Person(this.id, this.name);\n}\n</code></pre>"},{"location":"getting-started/#3-create-a-dao-data-access-object","title":"3. Create a DAO (Data Access Object)","text":"<p>This component is responsible for managing access to the underlying SQLite database. The abstract class contains the method signatures for querying the database which have to return a <code>Future</code> or <code>Stream</code>.</p> <ul> <li>You can define queries by adding the <code>@Query</code> annotation to a method.   The SQL statement has to get added in parenthesis.   The method must return a <code>Future</code> or <code>Stream</code> of the <code>Entity</code> you're querying for.</li> <li><code>@insert</code> marks a method as an insertion method.</li> </ul> <pre><code>// dao/person_dao.dart\n\nimport 'package:froom/froom.dart';\n\n@dao\nabstract class PersonDao {\n  @Query('SELECT * FROM Person')\n  Future&lt;List&lt;Person&gt;&gt; findAllPersons();\n\n  @Query('SELECT * FROM Person WHERE id = :id')\n  Stream&lt;Person?&gt; findPersonById(int id);\n\n  @insert\n  Future&lt;void&gt; insertPerson(Person person);\n}\n</code></pre>"},{"location":"getting-started/#4-create-the-database","title":"4. Create the Database","text":"<p>It has to be an abstract class which extends <code>FroomDatabase</code>. Furthermore, it's required to add <code>@Database()</code> to the signature of the class. Make sure to add the created entity to the <code>entities</code> attribute of the <code>@Database</code> annotation. In order to make the generated code work, it's required to also add the listed imports.</p> <p>Make sure to add <code>part 'database.g.dart';</code> beneath the imports of this file. It's important to note that 'database' has to get exchanged with the filename of the database definition. In this case, the file is named <code>database.dart</code>.</p> <pre><code>// database.dart\n\n// required package imports\nimport 'dart:async';\nimport 'package:froom/froom.dart';\nimport 'package:sqflite/sqflite.dart' as sqflite;\n\nimport 'dao/person_dao.dart';\nimport 'entity/person.dart';\n\npart 'database.g.dart'; // the generated code will be there\n\n@Database(version: 1, entities: [Person])\nabstract class AppDatabase extends FroomDatabase {\n  PersonDao get personDao;\n}\n</code></pre>"},{"location":"getting-started/#5-run-the-code-generator","title":"5. Run the Code Generator","text":"<p>Run the generator with <code>flutter packages pub run build_runner build</code>. To automatically run it, whenever a file changes, use <code>flutter packages pub run build_runner watch</code>.</p>"},{"location":"getting-started/#6-use-the-generated-code","title":"6. Use the Generated Code","text":"<p>For obtaining an instance of the database, use the generated <code>$FroomAppDatabase</code> class, which allows access to a database builder. The name is being composed by <code>$Froom</code> and the database class name. The string passed to <code>databaseBuilder()</code> will be the database file name. For initializing the database, call <code>build()</code> and make sure to <code>await</code> the result.</p> <p>In order to retrieve the <code>PersonDao</code> instance, invoking the <code>persoDao</code> getter on the database instance is enough. Its functions can be used as shown in the following snippet.</p> <pre><code>final database = await $FroomAppDatabase.databaseBuilder('app_database.db').build();\n\nfinal personDao = database.personDao;\nfinal person = Person(1, 'Frank');\n\nawait personDao.insertPerson(person);\nfinal result = await personDao.findPersonById(1);\n</code></pre> <p>For further examples take a look at the example and test directories.</p>"},{"location":"in-memory-database/","title":"In Memory Database","text":"<p>To instantiate an in-memory database, use the static <code>inMemoryDatabaseBuilder()</code> method of the generated <code>$FroomAppDatabase</code> class instead of <code>databaseBuilder()</code>.</p> <pre><code>final database = await $FroomAppDatabase.inMemoryDatabaseBuilder().build();\n</code></pre>"},{"location":"initialization-callback/","title":"Initialization Callback","text":"<p>In order to hook into Froom's database initialization process, <code>Callback</code> should be used. It allows the invocation of three separate callbacks which are triggered when the database has been</p> <ul> <li>initialized for the first time (<code>onCreate</code>).</li> <li>opened (<code>onOpen</code>).</li> <li>upgraded (<code>onUpgrade</code>).</li> </ul> <p>Each callback is optional.</p> <p>Their usage can be seen in the following snippet.</p> <pre><code>final callback = Callback(\n   onCreate: (database, version) { /* database has been created */ },\n   onOpen: (database) { /* database has been opened */ },\n   onUpgrade: (database, startVersion, endVersion) { /* database has been upgraded */ },\n);\n\nfinal database = await $FroomAppDatabase\n    .databaseBuilder('app_database.db')\n    .addCallback(callback)\n    .build();\n</code></pre>"},{"location":"isolates/","title":"Isolates","text":"<p>As froom is based on sqflite, Android and iOS apps access the SQLite database on a native background thread. On Linux, macOS, and Windows, a separate isolate is used. You can do some further reading on sqflite's background work mechanisms here.</p>"},{"location":"migration-from-floor/","title":"Migration from Floor to Froom","text":"<p>This guide will help you migrate your existing Floor project to Froom. Froom is built as a modern replacement for Floor, offering better compatibility with current Flutter versions and additional features.</p>"},{"location":"migration-from-floor/#version-compatibility","title":"Version Compatibility","text":"<p>Before migrating, ensure you're using the correct Froom version based on your dependencies:</p> source_gen Version Froom Version 3.x.x and above 3.x.x 2.x.x 2.0.4"},{"location":"migration-from-floor/#important-backup-your-project","title":"\u26a0\ufe0f Important: Backup Your Project","text":"<p>Before starting the migration, always create a complete backup of your project!</p> <p>You can create a backup by: <pre><code># Create a backup directory\ncp -r your_project_directory your_project_directory_backup\n\n# Or use git to commit your current state\ngit add .\ngit commit -m \"Backup before Floor to Froom migration\"\n</code></pre></p> <p>The automated migration script will also create a backup automatically, but it's always safer to have your own backup.</p>"},{"location":"migration-from-floor/#migration-steps","title":"Migration Steps","text":"<p>\ud83d\udca1 Recommended: Use our automated migration scripts to handle the migration process automatically. The manual steps below are for reference or custom migration needs.</p>"},{"location":"migration-from-floor/#1-update-dependencies","title":"1. Update Dependencies","text":"<p>Replace Floor dependencies with Froom in your <code>pubspec.yaml</code>:</p> <p>Before (Floor): <pre><code>dependencies:\n  floor: ^1.4.2\n\ndev_dependencies:\n  floor_generator: ^1.4.2\n  build_runner: ^2.1.2\n</code></pre></p> <p>After (Froom): <pre><code>dependencies:\n  froom: ^x.x.x\n\ndev_dependencies:\n  froom_generator: ^x.x.x\n  build_runner: ^x.x.x\n</code></pre></p> <p>\ud83d\udca1 Tip: Use command for easier installation: <pre><code>dart pub add froom dev:froom_generator dev:build_runner\n</code></pre> This command automatically adds the latest compatible versions without manually editing <code>pubspec.yaml</code>.</p>"},{"location":"migration-from-floor/#2-update-import-statements","title":"2. Update Import Statements","text":"<p>Replace all Floor package imports with Froom imports:</p> <p>Before: <pre><code>import 'package:floor/floor.dart';\nimport 'package:floor_annotation/floor_annotation.dart';\n</code></pre></p> <p>After: <pre><code>import 'package:froom/froom.dart';\nimport 'package:froom_annotation/froom_annotation.dart';\n</code></pre></p>"},{"location":"migration-from-floor/#3-update-database-class","title":"3. Update Database Class","text":"<p>Update your database class to extend <code>FroomDatabase</code> instead of <code>FloorDatabase</code>:</p> <p>Before: <pre><code>@Database(version: 1, entities: [Person])\nabstract class AppDatabase extends FloorDatabase {\n  PersonDao get personDao;\n}\n</code></pre></p> <p>After: <pre><code>@Database(version: 1, entities: [Person])\nabstract class AppDatabase extends FroomDatabase {\n  PersonDao get personDao;\n}\n</code></pre></p>"},{"location":"migration-from-floor/#4-update-database-builder","title":"4. Update Database Builder","text":"<p>Update the database builder class name:</p> <p>Before: <pre><code>final database = await $FloorAppDatabase.databaseBuilder('app_database.db').build();\n</code></pre></p> <p>After: <pre><code>final database = await $FroomAppDatabase.databaseBuilder('app_database.db').build();\n</code></pre></p>"},{"location":"migration-from-floor/#5-regenerate-code","title":"5. Regenerate Code","text":"<p>After making these changes, regenerate your database code:</p> <pre><code>flutter packages pub run build_runner clean\nflutter packages pub run build_runner build\n</code></pre>"},{"location":"migration-from-floor/#automated-migration-scripts","title":"Automated Migration Scripts","text":"<p>We provide migration scripts for different platforms to automate most of the migration process:</p> <p>\ud83d\udcc1 Script Location: All migration scripts can be found in the scripts directory of this repository.</p>"},{"location":"migration-from-floor/#linuxmacos-bash","title":"Linux/macOS (Bash)","text":"<pre><code># Make script executable\nchmod +x scripts/migrate_floor_to_froom.sh\n\n# Interactive mode (default) - asks before creating backup\n./scripts/migrate_floor_to_froom.sh\n\n# Force create backup without asking\n./scripts/migrate_floor_to_froom.sh --backup\n\n# Skip all confirmations (no backup)\n./scripts/migrate_floor_to_froom.sh --yes\n\n# Create backup and skip confirmations\n./scripts/migrate_floor_to_froom.sh --backup --yes\n\n# Specify project path (multiple ways)\n./scripts/migrate_floor_to_froom.sh /path/to/project              # Positional argument\n./scripts/migrate_floor_to_froom.sh --path /path/to/project       # Named option\n./scripts/migrate_floor_to_froom.sh -p /path/to/project           # Short option\n\n# Combined options\n./scripts/migrate_floor_to_froom.sh --path /path/to/project --backup --yes\n\n# Show help\n./scripts/migrate_floor_to_froom.sh --help\n</code></pre>"},{"location":"migration-from-floor/#windows-powershell","title":"Windows (PowerShell)","text":"<p>\u26a0\ufe0f PowerShell Execution Policy Notice:</p> <p>Windows PowerShell may restrict script execution due to security policies. If you encounter execution policy errors, you have several options:</p> <p>Option 1: Use the batch launcher (Recommended for most users) <pre><code># This automatically handles execution policy issues\n.\\scripts\\run_migration.bat\n</code></pre></p> <p>Option 2: Temporarily bypass execution policy <pre><code># Run migration with bypassed policy (one-time)\nPowerShell -ExecutionPolicy Bypass -File \".\\scripts\\migrate_floor_to_froom.ps1\"\n</code></pre></p> <p>Option 3: Change execution policy (Requires Administrator) <pre><code># Open PowerShell as Administrator and run:\nSet-ExecutionPolicy RemoteSigned -Scope CurrentUser\n\n# Or for system-wide (requires elevated permissions):\nSet-ExecutionPolicy RemoteSigned -Force\n</code></pre></p> <p>Option 4: Unrestricted execution (Less secure, not recommended) <pre><code># Temporarily allow all scripts (use with caution)\nSet-ExecutionPolicy Unrestricted -Scope CurrentUser\n\n# Remember to revert after migration:\nSet-ExecutionPolicy Restricted -Scope CurrentUser\n</code></pre></p> <p>Regular Usage (after policy is configured): <pre><code># Interactive mode (default) - asks before creating backup\n.\\scripts\\migrate_floor_to_froom.ps1\n\n# Force create backup without asking\n.\\scripts\\migrate_floor_to_froom.ps1 -Backup\n\n# Skip all confirmations (no backup)\n.\\scripts\\migrate_floor_to_froom.ps1 -Yes\n\n# Create backup and skip confirmations\n.\\scripts\\migrate_floor_to_froom.ps1 -Backup -Yes\n\n# Specify project path\n.\\scripts\\migrate_floor_to_froom.ps1 -Path \"C:\\path\\to\\project\"\n\n# Combined options\n.\\scripts\\migrate_floor_to_froom.ps1 -Path \"C:\\path\\to\\project\" -Backup -Yes\n\n# Show help\n.\\scripts\\migrate_floor_to_froom.ps1 -Help\n</code></pre></p>"},{"location":"migration-from-floor/#windows-batch-launcher","title":"Windows (Batch Launcher)","text":"<p>For Windows users who may have PowerShell execution policy restrictions:</p> <pre><code># GUI launcher that handles PowerShell execution policy automatically\n.\\scripts\\run_migration.bat\n</code></pre> <p>The batch launcher will: - Check PowerShell execution policy - Offer to bypass or change policy if needed - Provide an interactive menu to select migration scripts - Handle script arguments through prompts</p>"},{"location":"migration-from-floor/#available-options","title":"Available Options","text":"<p>Bash Scripts: | Option | Short | Description | |--------|-------|-------------| | <code>--backup</code> | <code>-b</code> | Create backup before migration | | <code>--yes</code> | <code>-y</code> | Skip confirmation prompts | | <code>--path PATH</code> | <code>-p PATH</code> | Specify project path | | <code>--help</code> | <code>-h</code> | Show help message |</p> <p>PowerShell Scripts: | Parameter | Description | |-----------|-------------| | <code>-Backup</code> | Create backup before migration | | <code>-Yes</code> | Skip confirmation prompts | | <code>-Path \"PATH\"</code> | Specify project path | | <code>-Help</code> | Show help message |</p>"},{"location":"migration-from-floor/#what-the-script-does","title":"What the Script Does","text":"<ul> <li>Update all Floor imports to Froom imports</li> <li>Replace <code>FloorDatabase</code> with <code>FroomDatabase</code></li> <li>Replace <code>$Floor</code> prefixes with <code>$Froom</code></li> <li>Update your <code>pubspec.yaml</code> dependencies</li> <li>Clean old generated files</li> </ul> <p>Note: The script can create automatic backups and provides interactive confirmations for safe migration.</p>"},{"location":"migration-from-floor/#manual-review-required","title":"Manual Review Required","text":"<p>After running the automated migration, you should manually review:</p> <ol> <li>pubspec.yaml - Ensure correct version numbers</li> <li>Generated files - Delete old <code>.g.dart</code> files and regenerate</li> <li>Custom code - Check any custom Floor-specific code that might need updates</li> <li>Tests - Update any tests that reference Floor classes</li> </ol>"},{"location":"migration-from-floor/#key-differences","title":"Key Differences","text":"<p>While Froom maintains API compatibility with Floor, there are some key improvements:</p> <ol> <li>Better analyzer support - Compatible with analyzer 7.x</li> <li>Modern dependencies - Updated to work with latest Flutter versions</li> <li>Improved error handling - Better debugging experience</li> <li>Active maintenance - Regular updates and bug fixes</li> </ol>"},{"location":"migration-from-floor/#troubleshooting","title":"Troubleshooting","text":""},{"location":"migration-from-floor/#common-issues","title":"Common Issues","text":"<ol> <li>Build errors after migration</li> <li>Clean and rebuild: <code>flutter packages pub run build_runner clean &amp;&amp; flutter packages pub run build_runner build</code></li> <li> <p>Delete existing <code>.g.dart</code> files manually if needed</p> </li> <li> <p>Import errors</p> </li> <li>Ensure all Floor imports are replaced with Froom imports</li> <li> <p>Check that you're using the correct Froom version</p> </li> <li> <p>Database builder errors</p> </li> <li> <p>Verify all <code>$Floor</code> prefixes are changed to <code>$Froom</code></p> </li> <li> <p>PowerShell execution policy errors (Windows)</p> </li> <li>Use the batch launcher: <code>.\\scripts\\run_migration.bat</code></li> <li>Or temporarily bypass: <code>PowerShell -ExecutionPolicy Bypass -File \".\\scripts\\migrate_floor_to_froom.ps1\"</code></li> <li>Or check current policy: <code>Get-ExecutionPolicy</code></li> </ol>"},{"location":"migration-from-floor/#getting-help","title":"Getting Help","text":"<p>If you encounter issues during migration:</p> <ul> <li>Check GitHub Issues for known issues</li> <li>Ask questions in GitHub Discussions</li> <li>Review the complete Froom documentation</li> </ul>"},{"location":"migration-from-floor/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Update <code>pubspec.yaml</code> dependencies</li> <li>[ ] Replace all Floor imports with Froom imports</li> <li>[ ] Update database class to extend <code>FroomDatabase</code></li> <li>[ ] Update database builder class names</li> <li>[ ] Run migration script (optional)</li> <li>[ ] Clean and regenerate code</li> <li>[ ] Test your application thoroughly</li> <li>[ ] Update any documentation references</li> </ul>"},{"location":"migrations/","title":"Migrations","text":"<p>Whenever you are doing changes to your entities, you're required to also migrate the old data.</p> <p>First, update your entity. Next, Increase the database version. Define a <code>Migration</code> which specifies a <code>startVersion</code>, an <code>endVersion</code> and a function that executes SQL to migrate the data. At last, use <code>addMigrations()</code> on the obtained database builder to add migrations. Don't forget to trigger the code generator again, to create the code for handling the new entity.</p> <pre><code>// update entity with new 'nickname' field\n@Entity(tableName: 'person')\nclass Person {\n  @PrimaryKey(autoGenerate: true)\n  final int id;\n\n  @ColumnInfo(name: 'custom_name')\n  final String name;\n\n  final String nickname;\n\n  Person(this.id, this.name, this.nickname);\n}\n\n// bump up database version\n@Database(version: 2)\nabstract class AppDatabase extends FroomDatabase {\n  PersonDao get personDao;\n}\n\n// create migration\nfinal migration1to2 = Migration(1, 2, (database) async {\n  await database.execute('ALTER TABLE person ADD COLUMN nickname TEXT');\n});\n\nfinal database = await $FroomAppDatabase\n    .databaseBuilder('app_database.db')\n    .addMigrations([migration1to2])\n    .build();\n</code></pre>"},{"location":"naming/","title":"Naming","text":"<p>The library's name derives from the following. Froom as the bottom layer of a Room which points to the analogy of the database layer being the bottom and foundation layer of most applications. Where fl also gives a pointer that the library is used in the Flutter context.</p>"},{"location":"null-safety/","title":"Null Safety","text":"<p>Froom infers nullability of database columns directly from entity fields, as mentioned in the Entities section. When not explicitly making a field nullable by applying <code>?</code> to its type, a column cannot hold <code>NULL</code>. For more information regarding <code>null</code>s as query results, see the Queries and Streams section. </p>"},{"location":"platform-support/","title":"Platform Support","text":"<p>Froom supports iOS, Android, Linux, macOS and Windows. The SQLite database access on iOS and Android is provided by sqflite whereas Linux, macOS and Windows use sqflite's ffi implementation.</p> <p>There currently is no support for Flutter for web.</p>"},{"location":"testing/","title":"Testing","text":"<p>Simply instantiate an in-memory database and run the database tests on your local development machine as shown in the following snippet. For more test references, check out the project's tests.</p> <p>In case you're running Linux, make sure to have sqlite3 and libsqlite3-dev installed.</p> <pre><code>import 'package:froom/froom.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\n// your imports follow here\nimport 'dao/person_dao.dart';\nimport 'database.dart';\nimport 'entity/person.dart';\n\nvoid main() {\n  group('database tests', () {\n    late TestDatabase database;\n    late PersonDao personDao;\n\n    setUp(() async {\n      database = await $FroomTestDatabase\n          .inMemoryDatabaseBuilder()\n          .build();\n      personDao = database.personDao;\n    });\n\n    tearDown(() async {\n      await database.close();\n    });\n\n    test('find person by id', () async {\n      final person = Person(1, 'Simon');\n      await personDao.insertPerson(person);\n\n      final actual = await personDao.findPersonById(person.id);\n\n      expect(actual, equals(person));\n    });\n  }\n}\n</code></pre>"},{"location":"type-converters/","title":"Type Converters","text":"<p>Attention</p> <p>This feature is still in an experimental state. Please use it with caution and file issues for problems you encounter.</p> <p>SQLite allows storing values of only a handful types. Whenever more complex Dart in-memory objects should be stored, there sometimes is the need for converting between Dart and SQLite compatible types. Dart's <code>DateTime</code>, for instance, provides an object-oriented API for handling time. Objects of this class can simply be represented as <code>int</code> values by mapping <code>DateTime</code> to its timestamp in milliseconds. Instead of manually mapping between these types repeatedly, when reading and writing, type converters can be used. It's sufficient to define the conversion from a database to an in-memory type and vice versa once, which then is reused automatically.</p> <p>The implementation and usage of the mentioned <code>DateTime</code> to <code>int</code> converter is described in the following.</p> <ol> <li> <p>Create a converter class that implements the abstract <code>TypeConverter</code> and supply the in-memory object type and database type as parameterized types.    This class inherits the <code>decode()</code> and <code>encode()</code> functions which define the conversion from one to the other type. <pre><code>class DateTimeConverter extends TypeConverter&lt;DateTime, int&gt; {\n  @override\n  DateTime decode(int databaseValue) {\n    return DateTime.fromMillisecondsSinceEpoch(databaseValue);\n  }\n\n  @override\n  int encode(DateTime value) {\n    return value.millisecondsSinceEpoch;\n  }\n}\n</code></pre></p> </li> <li> <p>Apply the created type converter to the database by using the <code>@TypeConverters</code> annotation and make sure to additionally import the file of your type converter here.    Importing it in your database file is always necessary because the generated code will be <code>part</code> of your database file and this is the location where your type converters get instantiated. <pre><code>@TypeConverters([DateTimeConverter])\n@Database(version: 1, entities: [Order])\nabstract class OrderDatabase extends FroomDatabase {\n  OrderDao get orderDao;\n}\n</code></pre></p> </li> <li> <p>Use the non-default <code>DateTime</code> type in an entity. <pre><code>@entity\nclass Order {\n  @primaryKey\n  final int id;\n\n  final DateTime date;\n\n  Order(this.id, this.date);\n}\n</code></pre></p> </li> </ol> <p>Type converters can be applied to</p> <ol> <li>databases</li> <li>DAOs</li> <li>entities/views</li> <li>entity/view fields</li> <li>DAO methods</li> <li>DAO method parameters</li> </ol> <p>The type converter is added to the scope of the element so if you put it on a class, all methods/fields in that class will be able to use the converter.</p> <p>The closest type converter wins! If you, for example, add a converter on the database level and another one on a DAO method parameter, which takes care of converting the same types, the one declared next to the DAO method parameter will be used. Please refer to the above list to get more information about the precedence of converters.</p>"}]}